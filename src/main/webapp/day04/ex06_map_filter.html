<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>map, some, every, filter, reduce</title>
</head>
<body>
	 <script type="text/javascript">
		// map : 메서드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다.
	 	const numbers = [1,4,9,16];
	 	/* const result = numbers.map(콜백함수); */
	 	const result = numbers.map(function(num) {
			// 배열의 각 요소마다 *2 하기
			// map은 인자로 받은 배열의 각각의 요소를 처리하기 때문에 이렇게 써도 됨
			return num*2
		});
	 	console.log(result);
	 	
	 	// 이 때 num은 numbers 배열의 각각의 요소를 말한다.
	 	const result2 = numbers.map((num)=>num*2);
	 	console.log(result2);
	 	
	 	// 요즘은 잘 안쓰는 방식
	 	// 그러나 DB정보나 클라이언트의 정보가 객체로 넘어오기 때문에 한번 처리해봐야한다.
	 	class Student{
	 		// 생성자
	 		constructor(name, kor, eng, math){
				// JS Class에서는 전역 변수를 굳이 만들지 않아도 된다.
	 			this.name=name;
				this.kor=kor;
				this.eng=eng;
				this.math=math;
			}
	 	}
	 	const student1 = new Student("홍길동",95,87,75);
	 	const student2 = new Student("김길동",67,80,100);
	 	const student3 = new Student("고길동",89,75,80);
	 	const student4 = new Student("최길동",48,52,98);
	 	
	 	const students= [student1,student2,student3,student4];
	 	
	 	console.log(`영어점수 : ${students.map((k)=>k.eng)}`)
	 	
	 	// some : 배열 안에서 주어진 조건을 하나라도 만족하면 true 반환
	 	console.log(`숫자가 7이상인 숫자가 있나요? : ${numbers.some((num)=>num>=7)}`) //true
	 	console.log(`수학점수가 100점인 학생이 있나요? : ${students.some((k)=>k.math ===100)}`) //true
	 	console.log(`영어점수가 50점 미만인 학생이 있나요? : ${students.some((k)=>k.eng < 50)}`) // false
	 	
	 	// every : 배안 안에서 주어진 조건을 모두 만족하면 true, 하나라도 만족하지 않으면 false
	 	console.log(`숫자가 모두 7이상인가요? : ${numbers.every((num) => num >= 7)}`) // false
	 	console.log(`수학점수가 모두 70점 이상인가요? : ${students.every((k)=>k.math >= 70)}`) //true
	 	
	 	// filter : 배열의 요소 중 주어진 조건을 만족하는 요소들만 모아서 배열로 반환
	 	console.log(`숫자 중 홀수만 출력하기 : ${numbers.filter((num) => num%2===1)}`)
	 	console.log("영어점수가 80점 이상인 학생만 출력하기 :", students.filter((k)=>k.eng >= 80))
	 	
	 	// reduce : 배열의 각 요소에 주어진 reduce함수를 실행하고, 하나의 결과값을 반환한다.
	 	// 리듀서 함수 : acc(누적값), cur(현재값), idx(현재 인덱스), src(원본 배열)
	 	// reduce함수는 최종 acc값을 디폴트값으로 반환해주며
	 	// 초기값은 acc의 초기값을 뜻한다.
	 	const numbers2 = [1,4,9,16];
	 	
	 	/* 
	 	numbers2.reduce((acc, cur, idx, src)=>{
	 		원하는 실행 내용
	 		return 원하는 리턴값(acc,cur,idx 등등)}, 초기값)
	 	*/
	 	numbers2.reduce((acc, cur, idx, src)=>{
	 		console.log(`acc:${acc}, cur:${cur}, idx:${idx}, src:${src}`);
	 		return acc}, 0)
	 	console.log("======================================")
	 	
	 	numbers2.reduce((acc, cur, idx, src)=>{
	 		console.log(`acc:${acc}, cur:${cur}, idx:${idx}, src:${src}`);
	 		return acc}, 1)
	 	console.log("======================================")
	 	
	 	// acc는 초기값을 가지고 한 싸이클이 돌때마다 다시 해당 값을 가지고 실행문으로 돌아가는 역할만 한다.
	 	// 따라서 현재값인 cur을 더해줌으로써 누적되면서 실행문으로 돌아갈 수 있다.
	 	numbers2.reduce((acc, cur, idx, src)=>{
	 		console.log(`acc:${acc}, cur:${cur}, idx:${idx}, src:${src}`);
	 		return acc+cur}, 0)
	 	console.log("======================================")
		
	 	// return값이 있기 때문에 변수로 받아서 확인해본다.
	 	const result3 = numbers2.reduce((acc, cur, idx, src)=>{
	 		console.log(`acc:${acc}, cur:${cur}, idx:${idx}, src:${src}`);
	 		return acc+cur}, 0)
	 	console.log(`결과 : ${result3}`)
	 	console.log("======================================")
	 	
	 	const fluits =["사과", "딸기", "배", "참외", "딸기", "수박"]
	 	// 비어있는 배열에서 함수 배열.includes(현재값) 을 이용해서 중복제거
	 	// 배열.includes(인자) => 배열 안에 인자로 들어온 값이 있으면 true반환
	 	console.log(fluits);
	 	const result4 = fluits.reduce((acc, cur)=>{
	 		if(acc.includes(cur) === false){
	 			acc.push(cur)
	 		}
	 		return acc;
	 		},[]);
	 	console.log(`결과 : ${result4}`)
	 </script>
</body>
</html>